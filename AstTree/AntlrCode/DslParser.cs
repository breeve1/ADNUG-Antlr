//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.2 Dsl.g 2019-08-21 20:50:42

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace ParserTree.AntlrCode
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.2")]
[System.CLSCompliant(false)]
public partial class DslParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND_STATEMENT", "APOSTRAPHE", "COMMENT", "DIGIT", "EQUAL", "GREATER", "GREATER_THAN", "GREATER_THAN_EQUAL", "INT", "IS", "LESS", "LESS_THAN", "LESS_THAN_EQUAL", "LETTER", "LINE_COMMENT_SLASH", "NEWLINE", "NOT", "NOT_EQUAL", "OR_STATEMENT", "PLUS", "PROGRAM", "STAR", "STRING_LITERAL", "THAN", "VARIABLE", "WHEN", "WHEN_STATEMENT", "WS", "'['", "']'"
	};
	public const int EOF=-1;
	public const int T__32=32;
	public const int T__33=33;
	public const int AND_STATEMENT=4;
	public const int APOSTRAPHE=5;
	public const int COMMENT=6;
	public const int DIGIT=7;
	public const int EQUAL=8;
	public const int GREATER=9;
	public const int GREATER_THAN=10;
	public const int GREATER_THAN_EQUAL=11;
	public const int INT=12;
	public const int IS=13;
	public const int LESS=14;
	public const int LESS_THAN=15;
	public const int LESS_THAN_EQUAL=16;
	public const int LETTER=17;
	public const int LINE_COMMENT_SLASH=18;
	public const int NEWLINE=19;
	public const int NOT=20;
	public const int NOT_EQUAL=21;
	public const int OR_STATEMENT=22;
	public const int PLUS=23;
	public const int PROGRAM=24;
	public const int STAR=25;
	public const int STRING_LITERAL=26;
	public const int THAN=27;
	public const int VARIABLE=28;
	public const int WHEN=29;
	public const int WHEN_STATEMENT=30;
	public const int WS=31;

	public DslParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public DslParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return DslParser.tokenNames; } }
	public override string GrammarFileName { get { return "Dsl.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// Dsl.g:26:8: public program : ( whenStatement )* EOF -> ^( PROGRAM ( whenStatement )* ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> whenStatement1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_whenStatement=new RewriteRuleSubtreeStream(adaptor,"rule whenStatement");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(26, 1);
		try
		{
			// Dsl.g:27:2: ( ( whenStatement )* EOF -> ^( PROGRAM ( whenStatement )* ) )
			DebugEnterAlt(1);
			// Dsl.g:27:4: ( whenStatement )* EOF
			{
			DebugLocation(27, 4);
			// Dsl.g:27:4: ( whenStatement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==NEWLINE||LA1_1==WHEN))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:27:4: whenStatement
					{
					DebugLocation(27, 4);
					PushFollow(Follow._whenStatement_in_program106);
					whenStatement1=whenStatement();
					PopFollow();

					stream_whenStatement.Add(whenStatement1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(27, 19);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_program109);  
			stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: whenStatement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 27:23: -> ^( PROGRAM ( whenStatement )* )
			{
				DebugLocation(27, 26);
				// Dsl.g:27:26: ^( PROGRAM ( whenStatement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(27, 28);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(27, 36);
				// Dsl.g:27:36: ( whenStatement )*
				while ( stream_whenStatement.HasNext )
				{
					DebugLocation(27, 36);
					adaptor.AddChild(root_1, stream_whenStatement.NextTree());

				}
				stream_whenStatement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_whenStatement();
	partial void LeaveRule_whenStatement();
	// $ANTLR start "whenStatement"
	// Dsl.g:30:1: whenStatement : ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+ -> ^( WHEN_STATEMENT booleanExpression ( booleanStatements )+ ) ;
	[GrammarRule("whenStatement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> whenStatement()
	{
		EnterRule_whenStatement();
		EnterRule("whenStatement", 2);
		TraceIn("whenStatement", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEWLINE3 = default(CommonToken);
		CommonToken WHEN4 = default(CommonToken);
		CommonToken NEWLINE6 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanStatements7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEWLINE3_tree = default(CommonTree);
		CommonTree WHEN4_tree = default(CommonTree);
		CommonTree NEWLINE6_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEWLINE=new RewriteRuleITokenStream(adaptor,"token NEWLINE");
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleSubtreeStream stream_booleanExpression=new RewriteRuleSubtreeStream(adaptor,"rule booleanExpression");
		RewriteRuleSubtreeStream stream_booleanStatements=new RewriteRuleSubtreeStream(adaptor,"rule booleanStatements");
		try { DebugEnterRule(GrammarFileName, "whenStatement");
		DebugLocation(30, 1);
		try
		{
			// Dsl.g:31:2: ( ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+ -> ^( WHEN_STATEMENT booleanExpression ( booleanStatements )+ ) )
			DebugEnterAlt(1);
			// Dsl.g:31:5: ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+
			{
			DebugLocation(31, 5);
			// Dsl.g:31:5: ( NEWLINE )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==NEWLINE))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:31:5: NEWLINE
					{
					DebugLocation(31, 5);
					NEWLINE3=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_whenStatement130);  
					stream_NEWLINE.Add(NEWLINE3);


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(31, 14);
			WHEN4=(CommonToken)Match(input,WHEN,Follow._WHEN_in_whenStatement133);  
			stream_WHEN.Add(WHEN4);

			DebugLocation(31, 19);
			PushFollow(Follow._booleanExpression_in_whenStatement135);
			booleanExpression5=booleanExpression();
			PopFollow();

			stream_booleanExpression.Add(booleanExpression5.Tree);
			DebugLocation(31, 37);
			// Dsl.g:31:37: ( NEWLINE )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==NEWLINE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:31:37: NEWLINE
					{
					DebugLocation(31, 37);
					NEWLINE6=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_whenStatement137);  
					stream_NEWLINE.Add(NEWLINE6);


					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(31, 46);
			// Dsl.g:31:46: ( booleanStatements )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==STAR))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:31:46: booleanStatements
					{
					DebugLocation(31, 46);
					PushFollow(Follow._booleanStatements_in_whenStatement140);
					booleanStatements7=booleanStatements();
					PopFollow();

					stream_booleanStatements.Add(booleanStatements7.Tree);

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }



			{
			// AST REWRITE
			// elements: booleanStatements, booleanExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 31:65: -> ^( WHEN_STATEMENT booleanExpression ( booleanStatements )+ )
			{
				DebugLocation(31, 68);
				// Dsl.g:31:68: ^( WHEN_STATEMENT booleanExpression ( booleanStatements )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(31, 70);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WHEN_STATEMENT, "WHEN_STATEMENT"), root_1);

				DebugLocation(31, 85);
				adaptor.AddChild(root_1, stream_booleanExpression.NextTree());
				DebugLocation(31, 103);
				if (!(stream_booleanStatements.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_booleanStatements.HasNext )
				{
					DebugLocation(31, 103);
					adaptor.AddChild(root_1, stream_booleanStatements.NextTree());

				}
				stream_booleanStatements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whenStatement", 2);
			LeaveRule("whenStatement", 2);
			LeaveRule_whenStatement();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "whenStatement"); }
		return retval;

	}
	// $ANTLR end "whenStatement"

	partial void EnterRule_booleanStatements();
	partial void LeaveRule_booleanStatements();
	// $ANTLR start "booleanStatements"
	// Dsl.g:34:1: booleanStatements : STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+ -> ^( AND_STATEMENT booleanExpression ( ^( OR_STATEMENT booleanExpression ) )* ) ;
	[GrammarRule("booleanStatements")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> booleanStatements()
	{
		EnterRule_booleanStatements();
		EnterRule("booleanStatements", 3);
		TraceIn("booleanStatements", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken STAR8 = default(CommonToken);
		CommonToken PLUS10 = default(CommonToken);
		CommonToken NEWLINE12 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression11 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree STAR8_tree = default(CommonTree);
		CommonTree PLUS10_tree = default(CommonTree);
		CommonTree NEWLINE12_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_NEWLINE=new RewriteRuleITokenStream(adaptor,"token NEWLINE");
		RewriteRuleSubtreeStream stream_booleanExpression=new RewriteRuleSubtreeStream(adaptor,"rule booleanExpression");
		try { DebugEnterRule(GrammarFileName, "booleanStatements");
		DebugLocation(34, 1);
		try
		{
			// Dsl.g:35:2: ( STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+ -> ^( AND_STATEMENT booleanExpression ( ^( OR_STATEMENT booleanExpression ) )* ) )
			DebugEnterAlt(1);
			// Dsl.g:35:4: STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+
			{
			DebugLocation(35, 4);
			STAR8=(CommonToken)Match(input,STAR,Follow._STAR_in_booleanStatements163);  
			stream_STAR.Add(STAR8);

			DebugLocation(35, 9);
			PushFollow(Follow._booleanExpression_in_booleanStatements165);
			booleanExpression9=booleanExpression();
			PopFollow();

			stream_booleanExpression.Add(booleanExpression9.Tree);
			DebugLocation(35, 27);
			// Dsl.g:35:27: ( PLUS booleanExpression )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==PLUS))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:35:28: PLUS booleanExpression
					{
					DebugLocation(35, 28);
					PLUS10=(CommonToken)Match(input,PLUS,Follow._PLUS_in_booleanStatements168);  
					stream_PLUS.Add(PLUS10);

					DebugLocation(35, 33);
					PushFollow(Follow._booleanExpression_in_booleanStatements170);
					booleanExpression11=booleanExpression();
					PopFollow();

					stream_booleanExpression.Add(booleanExpression11.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(35, 53);
			// Dsl.g:35:53: ( NEWLINE )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==NEWLINE))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Dsl.g:35:53: NEWLINE
					{
					DebugLocation(35, 53);
					NEWLINE12=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_booleanStatements174);  
					stream_NEWLINE.Add(NEWLINE12);


					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: booleanExpression, booleanExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 35:62: -> ^( AND_STATEMENT booleanExpression ( ^( OR_STATEMENT booleanExpression ) )* )
			{
				DebugLocation(35, 65);
				// Dsl.g:35:65: ^( AND_STATEMENT booleanExpression ( ^( OR_STATEMENT booleanExpression ) )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(35, 67);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(AND_STATEMENT, "AND_STATEMENT"), root_1);

				DebugLocation(35, 81);
				adaptor.AddChild(root_1, stream_booleanExpression.NextTree());
				DebugLocation(35, 99);
				// Dsl.g:35:99: ( ^( OR_STATEMENT booleanExpression ) )*
				while ( stream_booleanExpression.HasNext )
				{
					DebugLocation(35, 99);
					// Dsl.g:35:99: ^( OR_STATEMENT booleanExpression )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(35, 101);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(OR_STATEMENT, "OR_STATEMENT"), root_2);

					DebugLocation(35, 114);
					adaptor.AddChild(root_2, stream_booleanExpression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_booleanExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanStatements", 3);
			LeaveRule("booleanStatements", 3);
			LeaveRule_booleanStatements();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanStatements"); }
		return retval;

	}
	// $ANTLR end "booleanStatements"

	partial void EnterRule_booleanExpression();
	partial void LeaveRule_booleanExpression();
	// $ANTLR start "booleanExpression"
	// Dsl.g:38:1: booleanExpression : ( variable IS literal -> ^( EQUAL variable literal ) | variable IS NOT literal -> ^( NOT_EQUAL variable literal ) | variable GREATER THAN literal -> ^( GREATER_THAN variable literal ) | variable GREATER THAN EQUAL literal -> ^( GREATER_THAN_EQUAL variable literal ) | variable LESS THAN literal -> ^( LESS_THAN variable literal ) | variable LESS THAN EQUAL literal -> ^( LESS_THAN_EQUAL variable literal ) );
	[GrammarRule("booleanExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression()
	{
		EnterRule_booleanExpression();
		EnterRule("booleanExpression", 4);
		TraceIn("booleanExpression", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IS14 = default(CommonToken);
		CommonToken IS17 = default(CommonToken);
		CommonToken NOT18 = default(CommonToken);
		CommonToken GREATER21 = default(CommonToken);
		CommonToken THAN22 = default(CommonToken);
		CommonToken GREATER25 = default(CommonToken);
		CommonToken THAN26 = default(CommonToken);
		CommonToken EQUAL27 = default(CommonToken);
		CommonToken LESS30 = default(CommonToken);
		CommonToken THAN31 = default(CommonToken);
		CommonToken LESS34 = default(CommonToken);
		CommonToken THAN35 = default(CommonToken);
		CommonToken EQUAL36 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable13 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable20 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal23 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable29 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> variable33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree IS14_tree = default(CommonTree);
		CommonTree IS17_tree = default(CommonTree);
		CommonTree NOT18_tree = default(CommonTree);
		CommonTree GREATER21_tree = default(CommonTree);
		CommonTree THAN22_tree = default(CommonTree);
		CommonTree GREATER25_tree = default(CommonTree);
		CommonTree THAN26_tree = default(CommonTree);
		CommonTree EQUAL27_tree = default(CommonTree);
		CommonTree LESS30_tree = default(CommonTree);
		CommonTree THAN31_tree = default(CommonTree);
		CommonTree LESS34_tree = default(CommonTree);
		CommonTree THAN35_tree = default(CommonTree);
		CommonTree EQUAL36_tree = default(CommonTree);
		RewriteRuleITokenStream stream_GREATER=new RewriteRuleITokenStream(adaptor,"token GREATER");
		RewriteRuleITokenStream stream_THAN=new RewriteRuleITokenStream(adaptor,"token THAN");
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleITokenStream stream_LESS=new RewriteRuleITokenStream(adaptor,"token LESS");
		RewriteRuleSubtreeStream stream_variable=new RewriteRuleSubtreeStream(adaptor,"rule variable");
		RewriteRuleSubtreeStream stream_literal=new RewriteRuleSubtreeStream(adaptor,"rule literal");
		try { DebugEnterRule(GrammarFileName, "booleanExpression");
		DebugLocation(38, 1);
		try
		{
			// Dsl.g:39:2: ( variable IS literal -> ^( EQUAL variable literal ) | variable IS NOT literal -> ^( NOT_EQUAL variable literal ) | variable GREATER THAN literal -> ^( GREATER_THAN variable literal ) | variable GREATER THAN EQUAL literal -> ^( GREATER_THAN_EQUAL variable literal ) | variable LESS THAN literal -> ^( LESS_THAN variable literal ) | variable LESS THAN EQUAL literal -> ^( LESS_THAN_EQUAL variable literal ) )
			int alt7=6;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==32))
			{
				int LA7_2 = input.LA(2);

				if ((LA7_2==VARIABLE))
				{
					int LA7_3 = input.LA(3);

					if ((LA7_3==33))
					{
						switch (input.LA(4))
						{
						case IS:
							{
							int LA7_5 = input.LA(5);

							if ((LA7_5==NOT))
							{
								alt7 = 2;
							}
							else if ((LA7_5==INT||LA7_5==STRING_LITERAL))
							{
								alt7 = 1;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 7, 4, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case GREATER:
							{
							int LA7_5 = input.LA(5);

							if ((LA7_5==THAN))
							{
								int LA7_6 = input.LA(6);

								if ((LA7_6==EQUAL))
								{
									alt7 = 4;
								}
								else if ((LA7_6==INT||LA7_6==STRING_LITERAL))
								{
									alt7 = 3;
								}
								else
								{
									NoViableAltException nvae = new NoViableAltException("", 7, 9, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 7, 5, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case LESS:
							{
							int LA7_5 = input.LA(5);

							if ((LA7_5==THAN))
							{
								int LA7_6 = input.LA(6);

								if ((LA7_6==EQUAL))
								{
									alt7 = 6;
								}
								else if ((LA7_6==INT||LA7_6==STRING_LITERAL))
								{
									alt7 = 5;
								}
								else
								{
									NoViableAltException nvae = new NoViableAltException("", 7, 10, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 7, 6, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 7, 3, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Dsl.g:39:4: variable IS literal
				{
				DebugLocation(39, 4);
				PushFollow(Follow._variable_in_booleanExpression201);
				variable13=variable();
				PopFollow();

				stream_variable.Add(variable13.Tree);
				DebugLocation(39, 13);
				IS14=(CommonToken)Match(input,IS,Follow._IS_in_booleanExpression203);  
				stream_IS.Add(IS14);

				DebugLocation(39, 16);
				PushFollow(Follow._literal_in_booleanExpression205);
				literal15=literal();
				PopFollow();

				stream_literal.Add(literal15.Tree);


				{
				// AST REWRITE
				// elements: variable, literal
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 39:24: -> ^( EQUAL variable literal )
				{
					DebugLocation(39, 27);
					// Dsl.g:39:27: ^( EQUAL variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(39, 29);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EQUAL, "EQUAL"), root_1);

					DebugLocation(39, 35);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(39, 44);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Dsl.g:40:4: variable IS NOT literal
				{
				DebugLocation(40, 4);
				PushFollow(Follow._variable_in_booleanExpression220);
				variable16=variable();
				PopFollow();

				stream_variable.Add(variable16.Tree);
				DebugLocation(40, 13);
				IS17=(CommonToken)Match(input,IS,Follow._IS_in_booleanExpression222);  
				stream_IS.Add(IS17);

				DebugLocation(40, 16);
				NOT18=(CommonToken)Match(input,NOT,Follow._NOT_in_booleanExpression224);  
				stream_NOT.Add(NOT18);

				DebugLocation(40, 20);
				PushFollow(Follow._literal_in_booleanExpression226);
				literal19=literal();
				PopFollow();

				stream_literal.Add(literal19.Tree);


				{
				// AST REWRITE
				// elements: literal, variable
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 40:28: -> ^( NOT_EQUAL variable literal )
				{
					DebugLocation(40, 31);
					// Dsl.g:40:31: ^( NOT_EQUAL variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(40, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NOT_EQUAL, "NOT_EQUAL"), root_1);

					DebugLocation(40, 43);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(40, 52);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Dsl.g:41:4: variable GREATER THAN literal
				{
				DebugLocation(41, 4);
				PushFollow(Follow._variable_in_booleanExpression241);
				variable20=variable();
				PopFollow();

				stream_variable.Add(variable20.Tree);
				DebugLocation(41, 13);
				GREATER21=(CommonToken)Match(input,GREATER,Follow._GREATER_in_booleanExpression243);  
				stream_GREATER.Add(GREATER21);

				DebugLocation(41, 21);
				THAN22=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression245);  
				stream_THAN.Add(THAN22);

				DebugLocation(41, 26);
				PushFollow(Follow._literal_in_booleanExpression247);
				literal23=literal();
				PopFollow();

				stream_literal.Add(literal23.Tree);


				{
				// AST REWRITE
				// elements: literal, variable
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 41:34: -> ^( GREATER_THAN variable literal )
				{
					DebugLocation(41, 37);
					// Dsl.g:41:37: ^( GREATER_THAN variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(41, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GREATER_THAN, "GREATER_THAN"), root_1);

					DebugLocation(41, 52);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(41, 61);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Dsl.g:42:4: variable GREATER THAN EQUAL literal
				{
				DebugLocation(42, 4);
				PushFollow(Follow._variable_in_booleanExpression262);
				variable24=variable();
				PopFollow();

				stream_variable.Add(variable24.Tree);
				DebugLocation(42, 13);
				GREATER25=(CommonToken)Match(input,GREATER,Follow._GREATER_in_booleanExpression264);  
				stream_GREATER.Add(GREATER25);

				DebugLocation(42, 21);
				THAN26=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression266);  
				stream_THAN.Add(THAN26);

				DebugLocation(42, 26);
				EQUAL27=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_booleanExpression268);  
				stream_EQUAL.Add(EQUAL27);

				DebugLocation(42, 32);
				PushFollow(Follow._literal_in_booleanExpression270);
				literal28=literal();
				PopFollow();

				stream_literal.Add(literal28.Tree);


				{
				// AST REWRITE
				// elements: variable, literal
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 42:40: -> ^( GREATER_THAN_EQUAL variable literal )
				{
					DebugLocation(42, 43);
					// Dsl.g:42:43: ^( GREATER_THAN_EQUAL variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(42, 45);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GREATER_THAN_EQUAL, "GREATER_THAN_EQUAL"), root_1);

					DebugLocation(42, 64);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(42, 73);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Dsl.g:43:4: variable LESS THAN literal
				{
				DebugLocation(43, 4);
				PushFollow(Follow._variable_in_booleanExpression285);
				variable29=variable();
				PopFollow();

				stream_variable.Add(variable29.Tree);
				DebugLocation(43, 13);
				LESS30=(CommonToken)Match(input,LESS,Follow._LESS_in_booleanExpression287);  
				stream_LESS.Add(LESS30);

				DebugLocation(43, 18);
				THAN31=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression289);  
				stream_THAN.Add(THAN31);

				DebugLocation(43, 23);
				PushFollow(Follow._literal_in_booleanExpression291);
				literal32=literal();
				PopFollow();

				stream_literal.Add(literal32.Tree);


				{
				// AST REWRITE
				// elements: variable, literal
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 43:31: -> ^( LESS_THAN variable literal )
				{
					DebugLocation(43, 34);
					// Dsl.g:43:34: ^( LESS_THAN variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(43, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LESS_THAN, "LESS_THAN"), root_1);

					DebugLocation(43, 46);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(43, 55);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Dsl.g:44:4: variable LESS THAN EQUAL literal
				{
				DebugLocation(44, 4);
				PushFollow(Follow._variable_in_booleanExpression306);
				variable33=variable();
				PopFollow();

				stream_variable.Add(variable33.Tree);
				DebugLocation(44, 13);
				LESS34=(CommonToken)Match(input,LESS,Follow._LESS_in_booleanExpression308);  
				stream_LESS.Add(LESS34);

				DebugLocation(44, 18);
				THAN35=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression310);  
				stream_THAN.Add(THAN35);

				DebugLocation(44, 23);
				EQUAL36=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_booleanExpression312);  
				stream_EQUAL.Add(EQUAL36);

				DebugLocation(44, 29);
				PushFollow(Follow._literal_in_booleanExpression314);
				literal37=literal();
				PopFollow();

				stream_literal.Add(literal37.Tree);


				{
				// AST REWRITE
				// elements: literal, variable
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 44:37: -> ^( LESS_THAN_EQUAL variable literal )
				{
					DebugLocation(44, 40);
					// Dsl.g:44:40: ^( LESS_THAN_EQUAL variable literal )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(44, 42);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LESS_THAN_EQUAL, "LESS_THAN_EQUAL"), root_1);

					DebugLocation(44, 58);
					adaptor.AddChild(root_1, stream_variable.NextTree());
					DebugLocation(44, 67);
					adaptor.AddChild(root_1, stream_literal.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanExpression", 4);
			LeaveRule("booleanExpression", 4);
			LeaveRule_booleanExpression();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanExpression"); }
		return retval;

	}
	// $ANTLR end "booleanExpression"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();
	// $ANTLR start "variable"
	// Dsl.g:47:1: variable : '[' ! VARIABLE ^ ']' !;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 5);
		TraceIn("variable", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal38 = default(CommonToken);
		CommonToken VARIABLE39 = default(CommonToken);
		CommonToken char_literal40 = default(CommonToken);

		CommonTree char_literal38_tree = default(CommonTree);
		CommonTree VARIABLE39_tree = default(CommonTree);
		CommonTree char_literal40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(47, 1);
		try
		{
			// Dsl.g:48:2: ( '[' ! VARIABLE ^ ']' !)
			DebugEnterAlt(1);
			// Dsl.g:48:4: '[' ! VARIABLE ^ ']' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(48, 7);
			char_literal38=(CommonToken)Match(input,32,Follow._32_in_variable336); 
			DebugLocation(48, 18);
			VARIABLE39=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_variable340); 
			VARIABLE39_tree = (CommonTree)adaptor.Create(VARIABLE39);
			root_0 = (CommonTree)adaptor.BecomeRoot(VARIABLE39_tree, root_0);
			DebugLocation(48, 23);
			char_literal40=(CommonToken)Match(input,33,Follow._33_in_variable343); 

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 5);
			LeaveRule("variable", 5);
			LeaveRule_variable();
		}
		DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// Dsl.g:51:1: literal : ( STRING_LITERAL | INT );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 6);
		TraceIn("literal", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set41 = default(CommonToken);

		CommonTree set41_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(51, 1);
		try
		{
			// Dsl.g:52:2: ( STRING_LITERAL | INT )
			DebugEnterAlt(1);
			// Dsl.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(52, 2);

			set41=(CommonToken)input.LT(1);
			if (input.LA(1)==INT||input.LA(1)==STRING_LITERAL)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set41));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 6);
			LeaveRule("literal", 6);
			LeaveRule_literal();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _whenStatement_in_program106 = new BitSet(new ulong[]{0x20080000UL});
		public static readonly BitSet _EOF_in_program109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_whenStatement130 = new BitSet(new ulong[]{0x20080000UL});
		public static readonly BitSet _WHEN_in_whenStatement133 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _booleanExpression_in_whenStatement135 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _NEWLINE_in_whenStatement137 = new BitSet(new ulong[]{0x2080000UL});
		public static readonly BitSet _booleanStatements_in_whenStatement140 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _STAR_in_booleanStatements163 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _booleanExpression_in_booleanStatements165 = new BitSet(new ulong[]{0x880000UL});
		public static readonly BitSet _PLUS_in_booleanStatements168 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _booleanExpression_in_booleanStatements170 = new BitSet(new ulong[]{0x880000UL});
		public static readonly BitSet _NEWLINE_in_booleanStatements174 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _variable_in_booleanExpression201 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _IS_in_booleanExpression203 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_in_booleanExpression220 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _IS_in_booleanExpression222 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _NOT_in_booleanExpression224 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_in_booleanExpression241 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _GREATER_in_booleanExpression243 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _THAN_in_booleanExpression245 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_in_booleanExpression262 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _GREATER_in_booleanExpression264 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _THAN_in_booleanExpression266 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _EQUAL_in_booleanExpression268 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_in_booleanExpression285 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _LESS_in_booleanExpression287 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _THAN_in_booleanExpression289 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_in_booleanExpression306 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _LESS_in_booleanExpression308 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _THAN_in_booleanExpression310 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _EQUAL_in_booleanExpression312 = new BitSet(new ulong[]{0x4001000UL});
		public static readonly BitSet _literal_in_booleanExpression314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _32_in_variable336 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _VARIABLE_in_variable340 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_variable343 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace ParserTree.AntlrCode
