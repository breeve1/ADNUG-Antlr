//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g 2016-01-21 11:47:11

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class DslParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "APOSTRAPHE", "COMMENT", "DIGIT", "EQUAL", "GREATER", "INT", "IS", "LESS", "LETTER", "LINE_COMMENT_SLASH", "NEWLINE", "NOT", "PLUS", "STAR", "STRING_LITERAL", "THAN", "VARIABLE", "WHEN", "WS"
	};
	public const int EOF=-1;
	public const int APOSTRAPHE=4;
	public const int COMMENT=5;
	public const int DIGIT=6;
	public const int EQUAL=7;
	public const int GREATER=8;
	public const int INT=9;
	public const int IS=10;
	public const int LESS=11;
	public const int LETTER=12;
	public const int LINE_COMMENT_SLASH=13;
	public const int NEWLINE=14;
	public const int NOT=15;
	public const int PLUS=16;
	public const int STAR=17;
	public const int STRING_LITERAL=18;
	public const int THAN=19;
	public const int VARIABLE=20;
	public const int WHEN=21;
	public const int WS=22;

	public DslParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public DslParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return DslParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:11:8: public program : ( whenStatement )* EOF ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> whenStatement1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(11, 1);
		try
		{
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:12:2: ( ( whenStatement )* EOF )
			DebugEnterAlt(1);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:12:4: ( whenStatement )* EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(12, 4);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:12:4: ( whenStatement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==NEWLINE||LA1_1==WHEN))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:12:4: whenStatement
					{
					DebugLocation(12, 4);
					PushFollow(Follow._whenStatement_in_program47);
					whenStatement1=whenStatement();
					PopFollow();

					adaptor.AddChild(root_0, whenStatement1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(12, 19);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_program50); 
			EOF2_tree = (CommonTree)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(13, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_whenStatement();
	partial void LeaveRule_whenStatement();
	// $ANTLR start "whenStatement"
	// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:15:1: whenStatement : ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+ ;
	[GrammarRule("whenStatement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> whenStatement()
	{
		EnterRule_whenStatement();
		EnterRule("whenStatement", 2);
		TraceIn("whenStatement", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEWLINE3 = default(CommonToken);
		CommonToken WHEN4 = default(CommonToken);
		CommonToken NEWLINE6 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanStatements7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEWLINE3_tree = default(CommonTree);
		CommonTree WHEN4_tree = default(CommonTree);
		CommonTree NEWLINE6_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whenStatement");
		DebugLocation(15, 1);
		try
		{
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:2: ( ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+ )
			DebugEnterAlt(1);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:4: ( NEWLINE )* WHEN booleanExpression ( NEWLINE )+ ( booleanStatements )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(16, 4);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:4: ( NEWLINE )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==NEWLINE))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:4: NEWLINE
					{
					DebugLocation(16, 4);
					NEWLINE3=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_whenStatement61); 
					NEWLINE3_tree = (CommonTree)adaptor.Create(NEWLINE3);
					adaptor.AddChild(root_0, NEWLINE3_tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(16, 13);
			WHEN4=(CommonToken)Match(input,WHEN,Follow._WHEN_in_whenStatement64); 
			WHEN4_tree = (CommonTree)adaptor.Create(WHEN4);
			adaptor.AddChild(root_0, WHEN4_tree);
			DebugLocation(16, 18);
			PushFollow(Follow._booleanExpression_in_whenStatement66);
			booleanExpression5=booleanExpression();
			PopFollow();

			adaptor.AddChild(root_0, booleanExpression5.Tree);
			DebugLocation(16, 36);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:36: ( NEWLINE )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==NEWLINE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:36: NEWLINE
					{
					DebugLocation(16, 36);
					NEWLINE6=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_whenStatement68); 
					NEWLINE6_tree = (CommonTree)adaptor.Create(NEWLINE6);
					adaptor.AddChild(root_0, NEWLINE6_tree);

					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(16, 45);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:45: ( booleanStatements )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==STAR))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:16:45: booleanStatements
					{
					DebugLocation(16, 45);
					PushFollow(Follow._booleanStatements_in_whenStatement71);
					booleanStatements7=booleanStatements();
					PopFollow();

					adaptor.AddChild(root_0, booleanStatements7.Tree);

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whenStatement", 2);
			LeaveRule("whenStatement", 2);
			LeaveRule_whenStatement();
		}
		DebugLocation(17, 1);
		} finally { DebugExitRule(GrammarFileName, "whenStatement"); }
		return retval;

	}
	// $ANTLR end "whenStatement"

	partial void EnterRule_booleanStatements();
	partial void LeaveRule_booleanStatements();
	// $ANTLR start "booleanStatements"
	// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:19:1: booleanStatements : STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+ ;
	[GrammarRule("booleanStatements")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> booleanStatements()
	{
		EnterRule_booleanStatements();
		EnterRule("booleanStatements", 3);
		TraceIn("booleanStatements", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken STAR8 = default(CommonToken);
		CommonToken PLUS10 = default(CommonToken);
		CommonToken NEWLINE12 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression11 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree STAR8_tree = default(CommonTree);
		CommonTree PLUS10_tree = default(CommonTree);
		CommonTree NEWLINE12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "booleanStatements");
		DebugLocation(19, 1);
		try
		{
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:2: ( STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+ )
			DebugEnterAlt(1);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:4: STAR booleanExpression ( PLUS booleanExpression )* ( NEWLINE )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(20, 4);
			STAR8=(CommonToken)Match(input,STAR,Follow._STAR_in_booleanStatements83); 
			STAR8_tree = (CommonTree)adaptor.Create(STAR8);
			adaptor.AddChild(root_0, STAR8_tree);
			DebugLocation(20, 9);
			PushFollow(Follow._booleanExpression_in_booleanStatements85);
			booleanExpression9=booleanExpression();
			PopFollow();

			adaptor.AddChild(root_0, booleanExpression9.Tree);
			DebugLocation(20, 27);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:27: ( PLUS booleanExpression )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==PLUS))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:28: PLUS booleanExpression
					{
					DebugLocation(20, 28);
					PLUS10=(CommonToken)Match(input,PLUS,Follow._PLUS_in_booleanStatements88); 
					PLUS10_tree = (CommonTree)adaptor.Create(PLUS10);
					adaptor.AddChild(root_0, PLUS10_tree);
					DebugLocation(20, 33);
					PushFollow(Follow._booleanExpression_in_booleanStatements90);
					booleanExpression11=booleanExpression();
					PopFollow();

					adaptor.AddChild(root_0, booleanExpression11.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(20, 53);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:53: ( NEWLINE )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==NEWLINE))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:20:53: NEWLINE
					{
					DebugLocation(20, 53);
					NEWLINE12=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_booleanStatements94); 
					NEWLINE12_tree = (CommonTree)adaptor.Create(NEWLINE12);
					adaptor.AddChild(root_0, NEWLINE12_tree);

					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanStatements", 3);
			LeaveRule("booleanStatements", 3);
			LeaveRule_booleanStatements();
		}
		DebugLocation(21, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanStatements"); }
		return retval;

	}
	// $ANTLR end "booleanStatements"

	partial void EnterRule_booleanExpression();
	partial void LeaveRule_booleanExpression();
	// $ANTLR start "booleanExpression"
	// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:23:1: booleanExpression : ( VARIABLE IS literal | VARIABLE IS NOT literal | VARIABLE GREATER THAN literal | VARIABLE GREATER THAN EQUAL literal | VARIABLE LESS THAN literal | VARIABLE LESS THAN EQUAL literal );
	[GrammarRule("booleanExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> booleanExpression()
	{
		EnterRule_booleanExpression();
		EnterRule("booleanExpression", 4);
		TraceIn("booleanExpression", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken VARIABLE13 = default(CommonToken);
		CommonToken IS14 = default(CommonToken);
		CommonToken VARIABLE16 = default(CommonToken);
		CommonToken IS17 = default(CommonToken);
		CommonToken NOT18 = default(CommonToken);
		CommonToken VARIABLE20 = default(CommonToken);
		CommonToken GREATER21 = default(CommonToken);
		CommonToken THAN22 = default(CommonToken);
		CommonToken VARIABLE24 = default(CommonToken);
		CommonToken GREATER25 = default(CommonToken);
		CommonToken THAN26 = default(CommonToken);
		CommonToken EQUAL27 = default(CommonToken);
		CommonToken VARIABLE29 = default(CommonToken);
		CommonToken LESS30 = default(CommonToken);
		CommonToken THAN31 = default(CommonToken);
		CommonToken VARIABLE33 = default(CommonToken);
		CommonToken LESS34 = default(CommonToken);
		CommonToken THAN35 = default(CommonToken);
		CommonToken EQUAL36 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal23 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> literal37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree VARIABLE13_tree = default(CommonTree);
		CommonTree IS14_tree = default(CommonTree);
		CommonTree VARIABLE16_tree = default(CommonTree);
		CommonTree IS17_tree = default(CommonTree);
		CommonTree NOT18_tree = default(CommonTree);
		CommonTree VARIABLE20_tree = default(CommonTree);
		CommonTree GREATER21_tree = default(CommonTree);
		CommonTree THAN22_tree = default(CommonTree);
		CommonTree VARIABLE24_tree = default(CommonTree);
		CommonTree GREATER25_tree = default(CommonTree);
		CommonTree THAN26_tree = default(CommonTree);
		CommonTree EQUAL27_tree = default(CommonTree);
		CommonTree VARIABLE29_tree = default(CommonTree);
		CommonTree LESS30_tree = default(CommonTree);
		CommonTree THAN31_tree = default(CommonTree);
		CommonTree VARIABLE33_tree = default(CommonTree);
		CommonTree LESS34_tree = default(CommonTree);
		CommonTree THAN35_tree = default(CommonTree);
		CommonTree EQUAL36_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "booleanExpression");
		DebugLocation(23, 1);
		try
		{
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:24:2: ( VARIABLE IS literal | VARIABLE IS NOT literal | VARIABLE GREATER THAN literal | VARIABLE GREATER THAN EQUAL literal | VARIABLE LESS THAN literal | VARIABLE LESS THAN EQUAL literal )
			int alt7=6;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==VARIABLE))
			{
				switch (input.LA(2))
				{
				case IS:
					{
					int LA7_3 = input.LA(3);

					if ((LA7_3==NOT))
					{
						alt7 = 2;
					}
					else if ((LA7_3==INT||LA7_3==STRING_LITERAL))
					{
						alt7 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case GREATER:
					{
					int LA7_3 = input.LA(3);

					if ((LA7_3==THAN))
					{
						int LA7_4 = input.LA(4);

						if ((LA7_4==EQUAL))
						{
							alt7 = 4;
						}
						else if ((LA7_4==INT||LA7_4==STRING_LITERAL))
						{
							alt7 = 3;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 7, 7, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case LESS:
					{
					int LA7_3 = input.LA(3);

					if ((LA7_3==THAN))
					{
						int LA7_4 = input.LA(4);

						if ((LA7_4==EQUAL))
						{
							alt7 = 6;
						}
						else if ((LA7_4==INT||LA7_4==STRING_LITERAL))
						{
							alt7 = 5;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 7, 8, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 4, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:24:4: VARIABLE IS literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(24, 4);
				VARIABLE13=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression106); 
				VARIABLE13_tree = (CommonTree)adaptor.Create(VARIABLE13);
				adaptor.AddChild(root_0, VARIABLE13_tree);
				DebugLocation(24, 13);
				IS14=(CommonToken)Match(input,IS,Follow._IS_in_booleanExpression108); 
				IS14_tree = (CommonTree)adaptor.Create(IS14);
				adaptor.AddChild(root_0, IS14_tree);
				DebugLocation(24, 16);
				PushFollow(Follow._literal_in_booleanExpression110);
				literal15=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal15.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:25:4: VARIABLE IS NOT literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(25, 4);
				VARIABLE16=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression115); 
				VARIABLE16_tree = (CommonTree)adaptor.Create(VARIABLE16);
				adaptor.AddChild(root_0, VARIABLE16_tree);
				DebugLocation(25, 13);
				IS17=(CommonToken)Match(input,IS,Follow._IS_in_booleanExpression117); 
				IS17_tree = (CommonTree)adaptor.Create(IS17);
				adaptor.AddChild(root_0, IS17_tree);
				DebugLocation(25, 16);
				NOT18=(CommonToken)Match(input,NOT,Follow._NOT_in_booleanExpression119); 
				NOT18_tree = (CommonTree)adaptor.Create(NOT18);
				adaptor.AddChild(root_0, NOT18_tree);
				DebugLocation(25, 20);
				PushFollow(Follow._literal_in_booleanExpression121);
				literal19=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal19.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:26:4: VARIABLE GREATER THAN literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(26, 4);
				VARIABLE20=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression126); 
				VARIABLE20_tree = (CommonTree)adaptor.Create(VARIABLE20);
				adaptor.AddChild(root_0, VARIABLE20_tree);
				DebugLocation(26, 13);
				GREATER21=(CommonToken)Match(input,GREATER,Follow._GREATER_in_booleanExpression128); 
				GREATER21_tree = (CommonTree)adaptor.Create(GREATER21);
				adaptor.AddChild(root_0, GREATER21_tree);
				DebugLocation(26, 21);
				THAN22=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression130); 
				THAN22_tree = (CommonTree)adaptor.Create(THAN22);
				adaptor.AddChild(root_0, THAN22_tree);
				DebugLocation(26, 26);
				PushFollow(Follow._literal_in_booleanExpression132);
				literal23=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal23.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:27:4: VARIABLE GREATER THAN EQUAL literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(27, 4);
				VARIABLE24=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression137); 
				VARIABLE24_tree = (CommonTree)adaptor.Create(VARIABLE24);
				adaptor.AddChild(root_0, VARIABLE24_tree);
				DebugLocation(27, 13);
				GREATER25=(CommonToken)Match(input,GREATER,Follow._GREATER_in_booleanExpression139); 
				GREATER25_tree = (CommonTree)adaptor.Create(GREATER25);
				adaptor.AddChild(root_0, GREATER25_tree);
				DebugLocation(27, 21);
				THAN26=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression141); 
				THAN26_tree = (CommonTree)adaptor.Create(THAN26);
				adaptor.AddChild(root_0, THAN26_tree);
				DebugLocation(27, 26);
				EQUAL27=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_booleanExpression143); 
				EQUAL27_tree = (CommonTree)adaptor.Create(EQUAL27);
				adaptor.AddChild(root_0, EQUAL27_tree);
				DebugLocation(27, 32);
				PushFollow(Follow._literal_in_booleanExpression145);
				literal28=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal28.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:28:4: VARIABLE LESS THAN literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(28, 4);
				VARIABLE29=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression150); 
				VARIABLE29_tree = (CommonTree)adaptor.Create(VARIABLE29);
				adaptor.AddChild(root_0, VARIABLE29_tree);
				DebugLocation(28, 13);
				LESS30=(CommonToken)Match(input,LESS,Follow._LESS_in_booleanExpression152); 
				LESS30_tree = (CommonTree)adaptor.Create(LESS30);
				adaptor.AddChild(root_0, LESS30_tree);
				DebugLocation(28, 18);
				THAN31=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression154); 
				THAN31_tree = (CommonTree)adaptor.Create(THAN31);
				adaptor.AddChild(root_0, THAN31_tree);
				DebugLocation(28, 23);
				PushFollow(Follow._literal_in_booleanExpression156);
				literal32=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal32.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:29:4: VARIABLE LESS THAN EQUAL literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(29, 4);
				VARIABLE33=(CommonToken)Match(input,VARIABLE,Follow._VARIABLE_in_booleanExpression161); 
				VARIABLE33_tree = (CommonTree)adaptor.Create(VARIABLE33);
				adaptor.AddChild(root_0, VARIABLE33_tree);
				DebugLocation(29, 13);
				LESS34=(CommonToken)Match(input,LESS,Follow._LESS_in_booleanExpression163); 
				LESS34_tree = (CommonTree)adaptor.Create(LESS34);
				adaptor.AddChild(root_0, LESS34_tree);
				DebugLocation(29, 18);
				THAN35=(CommonToken)Match(input,THAN,Follow._THAN_in_booleanExpression165); 
				THAN35_tree = (CommonTree)adaptor.Create(THAN35);
				adaptor.AddChild(root_0, THAN35_tree);
				DebugLocation(29, 23);
				EQUAL36=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_booleanExpression167); 
				EQUAL36_tree = (CommonTree)adaptor.Create(EQUAL36);
				adaptor.AddChild(root_0, EQUAL36_tree);
				DebugLocation(29, 29);
				PushFollow(Follow._literal_in_booleanExpression169);
				literal37=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal37.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanExpression", 4);
			LeaveRule("booleanExpression", 4);
			LeaveRule_booleanExpression();
		}
		DebugLocation(30, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanExpression"); }
		return retval;

	}
	// $ANTLR end "booleanExpression"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:33:1: literal : ( STRING_LITERAL | INT );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 5);
		TraceIn("literal", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set38 = default(CommonToken);

		CommonTree set38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(33, 1);
		try
		{
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:34:2: ( STRING_LITERAL | INT )
			DebugEnterAlt(1);
			// C:\\Data\\ADNug-Antlr\\Code\\Raw\\Parser\\Dsl.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(34, 2);

			set38=(CommonToken)input.LT(1);
			if (input.LA(1)==INT||input.LA(1)==STRING_LITERAL)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set38));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 5);
			LeaveRule("literal", 5);
			LeaveRule_literal();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _whenStatement_in_program47 = new BitSet(new ulong[]{0x0000000000204000UL});
		public static readonly BitSet _EOF_in_program50 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _NEWLINE_in_whenStatement61 = new BitSet(new ulong[]{0x0000000000204000UL});
		public static readonly BitSet _WHEN_in_whenStatement64 = new BitSet(new ulong[]{0x0000000000100000UL});
		public static readonly BitSet _booleanExpression_in_whenStatement66 = new BitSet(new ulong[]{0x0000000000004000UL});
		public static readonly BitSet _NEWLINE_in_whenStatement68 = new BitSet(new ulong[]{0x0000000000024000UL});
		public static readonly BitSet _booleanStatements_in_whenStatement71 = new BitSet(new ulong[]{0x0000000000020002UL});
		public static readonly BitSet _STAR_in_booleanStatements83 = new BitSet(new ulong[]{0x0000000000100000UL});
		public static readonly BitSet _booleanExpression_in_booleanStatements85 = new BitSet(new ulong[]{0x0000000000014000UL});
		public static readonly BitSet _PLUS_in_booleanStatements88 = new BitSet(new ulong[]{0x0000000000100000UL});
		public static readonly BitSet _booleanExpression_in_booleanStatements90 = new BitSet(new ulong[]{0x0000000000014000UL});
		public static readonly BitSet _NEWLINE_in_booleanStatements94 = new BitSet(new ulong[]{0x0000000000004002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression106 = new BitSet(new ulong[]{0x0000000000000400UL});
		public static readonly BitSet _IS_in_booleanExpression108 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression110 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression115 = new BitSet(new ulong[]{0x0000000000000400UL});
		public static readonly BitSet _IS_in_booleanExpression117 = new BitSet(new ulong[]{0x0000000000008000UL});
		public static readonly BitSet _NOT_in_booleanExpression119 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression121 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression126 = new BitSet(new ulong[]{0x0000000000000100UL});
		public static readonly BitSet _GREATER_in_booleanExpression128 = new BitSet(new ulong[]{0x0000000000080000UL});
		public static readonly BitSet _THAN_in_booleanExpression130 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression132 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression137 = new BitSet(new ulong[]{0x0000000000000100UL});
		public static readonly BitSet _GREATER_in_booleanExpression139 = new BitSet(new ulong[]{0x0000000000080000UL});
		public static readonly BitSet _THAN_in_booleanExpression141 = new BitSet(new ulong[]{0x0000000000000080UL});
		public static readonly BitSet _EQUAL_in_booleanExpression143 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression145 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression150 = new BitSet(new ulong[]{0x0000000000000800UL});
		public static readonly BitSet _LESS_in_booleanExpression152 = new BitSet(new ulong[]{0x0000000000080000UL});
		public static readonly BitSet _THAN_in_booleanExpression154 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression156 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VARIABLE_in_booleanExpression161 = new BitSet(new ulong[]{0x0000000000000800UL});
		public static readonly BitSet _LESS_in_booleanExpression163 = new BitSet(new ulong[]{0x0000000000080000UL});
		public static readonly BitSet _THAN_in_booleanExpression165 = new BitSet(new ulong[]{0x0000000000000080UL});
		public static readonly BitSet _EQUAL_in_booleanExpression167 = new BitSet(new ulong[]{0x0000000000040200UL});
		public static readonly BitSet _literal_in_booleanExpression169 = new BitSet(new ulong[]{0x0000000000000002UL});
	}
	#endregion Follow sets
}
